"""
Bind9 DNS zone management for MRM Webpanel.
Creates and manages DNS zones, records (A, MX, TXT for SPF/DKIM/DMARC).
"""

import os
import subprocess
import logging
from pathlib import Path
from datetime import datetime

logger = logging.getLogger(__name__)

BIND_ZONES_DIR = os.environ.get('BIND_ZONES_DIR', '/etc/bind/zones')
BIND_CONF_LOCAL = os.environ.get('BIND_CONF_LOCAL', '/etc/bind/named.conf.local')
BIND_CONF_BACKUP = f"{BIND_CONF_LOCAL}.bak"

# Default zone template
ZONE_TEMPLATE = """; Zone file for {domain}
; Generated by MRM Webpanel
$ORIGIN {domain}.
$TTL 3600

@       IN      SOA     ns1.{domain_base}. admin.{domain_base}. (
                        {serial}         ; Serial
                        3600             ; Refresh
                        1800             ; Retry
                        604800           ; Expire
                        86400            ; Minimum
                        )

@       IN      NS      ns1.{domain_base}.
@       IN      NS      ns2.{domain_base}.

@       IN      A       {ipv4}
www     IN      A       {ipv4}

@       IN      MX      10 mail.{domain}.

; SPF record (adjust as needed)
@       IN      TXT     "v=spf1 mx ~all"

; DKIM placeholder (will be populated by panel)
; default._domainkey  IN  TXT     "v=DKIM1; k=rsa; p=..."

; DMARC placeholder (will be populated by panel)
; _dmarc  IN  TXT     "v=DMARC1; p=none; rua=mailto:admin@{domain}"

; Mail servers
mail    IN      A       {ipv4}
pop3    IN      A       {ipv4}
imap    IN      A       {ipv4}
smtp    IN      A       {ipv4}
"""

class Bind9Manager:
    """Manage Bind9 DNS zones and records."""
    
    def __init__(self, domain, ipv4, nameserver_base=None):
        self.domain = domain
        self.ipv4 = ipv4
        self.nameserver_base = nameserver_base or self._extract_domain_base(domain)
        self.zone_file = os.path.join(BIND_ZONES_DIR, f"db.{domain}")
    
    @staticmethod
    def _extract_domain_base(domain):
        """Extract base domain from full domain."""
        parts = domain.split('.')
        if len(parts) > 2:
            return '.'.join(parts[1:])
        return domain
    
    def create_zone_directory(self):
        """Ensure zone directory exists."""
        os.makedirs(BIND_ZONES_DIR, exist_ok=True)
        logger.info(f"Ensured zone directory {BIND_ZONES_DIR}")
    
    def generate_zone_file(self):
        """Generate zone file from template."""
        self.create_zone_directory()
        
        # Get current date for serial
        now = datetime.utcnow()
        serial = int(now.strftime('%Y%m%d%H'))
        
        zone_content = ZONE_TEMPLATE.format(
            domain=self.domain,
            domain_base=self.nameserver_base,
            ipv4=self.ipv4,
            serial=serial
        )
        
        with open(self.zone_file, 'w') as f:
            f.write(zone_content)
        
        # Set proper permissions
        os.chmod(self.zone_file, 0o644)
        
        logger.info(f"Generated zone file for {self.domain}")
        return True
    
    def add_zone_to_config(self):
        """Add zone entry to named.conf.local."""
        zone_entry = f"\nzone \"{self.domain}\" {{\n    type master;\n    file \"{self.zone_file}\";\n}};\n"
        
        # Backup original
        if os.path.exists(BIND_CONF_LOCAL):
            with open(BIND_CONF_LOCAL, 'r') as f:
                content = f.read()
            
            # Check if zone already configured
            if f'zone "{self.domain}"' in content:
                logger.info(f"Zone {self.domain} already in config")
                return True
            
            # Create backup
            with open(BIND_CONF_BACKUP, 'w') as f:
                f.write(content)
        
        # Append zone entry
        with open(BIND_CONF_LOCAL, 'a') as f:
            f.write(zone_entry)
        
        logger.info(f"Added zone {self.domain} to {BIND_CONF_LOCAL}")
        return True
    
    def test_zone_syntax(self):
        """Test zone file syntax using named-checkzone."""
        try:
            result = subprocess.run(
                ['named-checkzone', self.domain, self.zone_file],
                capture_output=True,
                text=True
            )
            if result.returncode == 0:
                logger.info(f"Zone {self.domain} syntax valid")
                return True
            else:
                logger.error(f"Zone syntax error: {result.stderr}")
                return False
        except FileNotFoundError:
            logger.warning("named-checkzone not found, skipping syntax check")
            return True
    
    def test_config_syntax(self):
        """Test Bind9 config syntax."""
        try:
            result = subprocess.run(
                ['named-checkconf', BIND_CONF_LOCAL],
                capture_output=True,
                text=True
            )
            if result.returncode == 0:
                logger.info("Bind9 config syntax valid")
                return True
            else:
                logger.error(f"Config syntax error: {result.stderr}")
                return False
        except FileNotFoundError:
            logger.warning("named-checkconf not found, skipping check")
            return True
    
    def reload_bind9(self):
        """Reload Bind9 to apply changes."""
        try:
            subprocess.run(['rndc', 'reload'], check=True, capture_output=True)
            logger.info("Bind9 reloaded successfully")
            return True
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to reload Bind9: {e}")
            return False
        except FileNotFoundError:
            logger.error("rndc not found")
            return False
    
    def add_dns_record(self, name, record_type, value, ttl=3600, priority=None):
        """Add or update a DNS record in the zone file."""
        # Read current zone file
        with open(self.zone_file, 'r') as f:
            lines = f.readlines()
        
        # Remove existing record with same name and type if present
        lines = [line for line in lines if not (f"{name} " in line and f"IN {record_type}" in line)]
        
        # Format the new record
        if priority:
            record_line = f"{name:20} {ttl:6} IN {record_type:6} {priority:3} {value}\n"
        else:
            record_line = f"{name:20} {ttl:6} IN {record_type:6} {value}\n"
        
        # Find insertion point (after SOA, before comments usually)
        insertion_idx = 0
        for i, line in enumerate(lines):
            if line.strip().startswith(';'):
                insertion_idx = i
                break
        
        lines.insert(insertion_idx, record_line)
        
        # Write back
        with open(self.zone_file, 'w') as f:
            f.writelines(lines)
        
        logger.info(f"Added {record_type} record for {name} in {self.domain}")
        return True
    
    def add_dkim_record(self, selector, public_key):
        """Add DKIM public key to zone."""
        # DKIM TXT record format
        dkim_record = f"v=DKIM1; k=rsa; p={public_key}"
        return self.add_dns_record(f"{selector}._domainkey", "TXT", f'"{dkim_record}"')
    
    def add_spf_record(self, spf_policy="v=spf1 mx ~all"):
        """Add or update SPF record."""
        return self.add_dns_record("@", "TXT", f'"{spf_policy}"')
    
    def add_dmarc_record(self, dmarc_policy="v=DMARC1; p=none"):
        """Add or update DMARC record."""
        return self.add_dns_record("_dmarc", "TXT", f'"{dmarc_policy}"')
    
    def deploy(self):
        """Full deployment: create zone file, add to config, reload."""
        try:
            if not self.generate_zone_file():
                return False
            
            if not self.test_zone_syntax():
                logger.warning("Zone syntax check failed, but continuing")
            
            if not self.add_zone_to_config():
                return False
            
            if not self.test_config_syntax():
                return False
            
            if not self.reload_bind9():
                return False
            
            logger.info(f"Successfully deployed DNS zone for {self.domain}")
            return True
        except Exception as e:
            logger.error(f"Deployment failed: {e}")
            return False
    
    def destroy(self):
        """Remove zone: delete zone file and remove from config."""
        try:
            # Remove zone file
            if os.path.exists(self.zone_file):
                os.remove(self.zone_file)
                logger.info(f"Removed zone file {self.zone_file}")
            
            # Remove from config
            if os.path.exists(BIND_CONF_LOCAL):
                with open(BIND_CONF_LOCAL, 'r') as f:
                    lines = f.readlines()
                
                # Filter out zone entry
                new_lines = []
                skip = False
                for line in lines:
                    if f'zone "{self.domain}"' in line:
                        skip = True
                    elif skip and line.strip() == '};':
                        skip = False
                        continue
                    elif not skip:
                        new_lines.append(line)
                
                with open(BIND_CONF_LOCAL, 'w') as f:
                    f.writelines(new_lines)
            
            if not self.reload_bind9():
                return False
            
            logger.info(f"Successfully destroyed DNS zone for {self.domain}")
            return True
        except Exception as e:
            logger.error(f"Destruction failed: {e}")
            return False
